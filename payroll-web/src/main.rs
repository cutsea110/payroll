use log::{debug, info, trace};
use std::net::TcpListener;

use hs_db::HashDB;
use payroll_web::AppConfig;
use threadpool::ThreadPool;

fn print_header(_app_conf: &payroll_web::AppConfig) {
    trace!("print_header called");
    // this banner generated by using `figlet -f slant 'payro$$'`
    let lines = vec![
        r#"                                   __  __"#,
        r#"    ____  ____ ___  ___________  _/ /_/ /"#,
        r#"   / __ \/ __ `/ / / / ___/ __ \/ __/ __/"#,
        r#"  / /_/ / /_/ / /_/ / /  / /_/ (_  |_  ) "#,
        r#" / .___/\__,_/\__, /_/   \____/  _/  _/  "#,
        r#"/_/          /____/           /_/ /_/    "#,
        r#"When you quit, you press Ctrl-D."#,
    ];
    eprintln!("{}", lines.join("\n"));
}

fn main() -> Result<(), anyhow::Error> {
    env_logger::Builder::from_default_env()
        .format_source_path(true)
        .format_line_number(true)
        .init();

    info!("Starting server...");

    let app_conf = AppConfig::new()?;
    debug!("main: app_conf={:#?}", app_conf);
    if app_conf.should_show_help() {
        debug!("main: should show help");
        println!("{}", app_conf.help_message());
        return Ok(());
    }
    if !app_conf.should_run_quietly() {
        debug!("main: shouldn't run quietly");
        print_header(&app_conf);
    }

    let pool = ThreadPool::new(app_conf.threads());
    let handler = app_conf.build_handler(HashDB::new());
    let listener = TcpListener::bind(&app_conf.sock_addr())
        .expect(&format!("Bind to {}", app_conf.sock_addr()));

    for stream in listener.incoming() {
        trace!("Incoming connection");
        let stream = stream.expect("accept connection");
        let handler = handler.clone();

        pool.execute(move || {
            handler.handle_connection(stream);
        });
    }

    info!("Shutting down.");
    Ok(())
}
